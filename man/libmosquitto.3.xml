<?xml version='1.0' encoding='ISO-8859-1'?>
<?xml-stylesheet type="text/xsl" href="http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "/usr/share/sgml/docbook/xml-dtd-4.4/docbookx.dtd">

<refentry xml:id="libmosquitto">
	<refmeta>
		<refentrytitle>libmosquitto</refentrytitle>
		<manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
		<refname>libmosquitto</refname>
		<refpurpose>MQTT version 3 client library</refpurpose>
	</refnamediv>

	<refsect1>
		<title>Description</title>
		<para>This is an overview of how to use libmosquitto to create MQTT
		aware client programs. There (will be) separate man pages on each of
		the functions described here. There are also bindings for libmosquitto
		for C++ and Python. They are not documented here.</para>
	</refsect1>

	<refsect1>
		<title>Functions</title>
<!--

struct mosquitto *mosquitto_new(void *obj, const char *id);
int mosquitto_will_set(struct mosquitto *mosq, bool will, const char *topic, uint32_t payloadlen, const uint8_t *payload, int qos, bool retain);
void mosquitto_destroy(struct mosquitto *mosq);
int mosquitto_connect(struct mosquitto *mosq, const char *host, int port, int keepalive, bool clean_session);
int mosquitto_disconnect(struct mosquitto *mosq);
int mosquitto_publish(struct mosquitto *mosq, uint16_t *mid, const char *topic, uint32_t payloadlen, const uint8_t *payload, int qos, bool retain);
int mosquitto_subscribe(struct mosquitto *mosq, const char *sub, int qos);
int mosquitto_unsubscribe(struct mosquitto *mosq, const char *sub);
int mosquitto_loop(struct mosquitto *mosq, struct timespec *timeout);
int mosquitto_read(struct mosquitto *mosq);
int mosquitto_write(struct mosquitto *mosq);

void mosquitto_connect_callback_set(struct mosquitto *mosq, void (*on_connect)(void *, int));
void mosquitto_publish_callback_set(struct mosquitto *mosq, void (*on_publish)(void *, uint16_t));
void mosquitto_message_callback_set(struct mosquitto *mosq, void (*on_message)(void *, struct mosquitto_message *));
void mosquitto_subscribe_callback_set(struct mosquitto *mosq, void (*on_subscribe)(void *, uint16_t, int, uint8_t *));
void mosquitto_unsubscribe_callback_set(struct mosquitto *mosq, void (*on_unsubscribe)(void *, uint16_t));

void mosquitto_message_retry_check(struct mosquitto *mosq);
void mosquitto_message_retry_set(struct mosquitto *mosq, unsigned int message_retry);
void mosquitto_message_cleanup(struct mosquitto_message **message);

int mosquitto_log_init(struct mosquitto *mosq, int priorities, int destinations);
-->
	</refsect1>

	<refsect1>
		<title>libmosquitto symbol names</title>
		<para>All public functions in libmosquitto have the prefix
		"mosquitto_". Any other functions defined in the source code are to be
		treated as private functions and may change between any release. Do not
		use these functions!</para>
	</refsect1>

	<refsect1>
		<title>Examples</title>
		<para><programlisting language="C">
#include &lt;mosquitto.h&gt;

void my_message_callback(void *obj, struct mosquitto_message *message)
{
	if(message->payloadlen){
		printf("%s %s\n", message->topic, message->payload);
	}else{
		printf("%s (null)\n", message->topic);
	}
	fflush(stdout);
}

void my_connect_callback(void *obj, int result)
{
	struct mosquitto *mosq = obj;

	int i;
	if(!result){
		mosquitto_subscribe(mosq, topics[i], topic_qos);
	}else{
		fprintf(stderr, "Connect failed\n");
	}
}

void my_subscribe_callback(void *obj, uint16_t mid, int qos_count, uint8_t *granted_qos)
{
	int i;

	printf("Subscribed (mid: %d): %d", mid, granted_qos[0]);
	for(i=1; i&lt;qos_count; i++){
		printf(", %d", granted_qos[i]);
	}
	printf("\n");
	free(granted_qos);
}

int main(int argc, char *argv[])
{
	char id[30];
	int i;
	char *host = "localhost";
	int port = 1883;
	int keepalive = 60;
	bool clean_session = true;
	struct mosquitto *mosq = NULL;

	mosq = mosquitto_new(NULL, id);
	if(!mosq){
		fprintf(stderr, "Error: Out of memory.\n");
		return 1;
	}
	mosquitto_log_init(mosq, MOSQ_LOG_DEBUG | MOSQ_LOG_ERR | MOSQ_LOG_WARNING
			| MOSQ_LOG_NOTICE | MOSQ_LOG_INFO, MOSQ_LOG_STDERR);

	mosquitto_connect_callback_set(mosq, my_connect_callback);
	mosquitto_message_callback_set(mosq, my_message_callback);
	mosq->on_subscribe = my_subscribe_callback;

	if(mosquitto_connect(mosq, host, port, keepalive, clean_session)){
		fprintf(stderr, "Unable to connect.\n");
		return 1;
	}

	while(!mosquitto_loop(mosq, NULL)){
	}
	mosquitto_destroy(mosq);
	return 0;
}
		</programlisting></para>
	</refsect1>
	<refsect1>
		<title>See Also</title>
		<para>
			<citerefentry>
				<refentrytitle>mosquitto</refentrytitle>
				<manvolnum>8</manvolnum>
			</citerefentry>
			<citerefentry>
				<refentrytitle>mqtt</refentrytitle>
				<manvolnum>7</manvolnum>
			</citerefentry>
		</para>
	</refsect1>

	<refsect1>
		<title>Author</title>
		<para>Roger Light <email>roger@atchoo.org</email></para>
	</refsect1>
</refentry>

